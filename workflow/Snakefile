"""
Lab Virome QC Pipeline - Modular Version
=========================================

A modular, flexible pipeline for virome data QC and assembly.

Pipeline Modes:
1. Full pipeline: QC → Assembly
2. QC only: Stop after generating cleaned reads
3. Assembly from cleaned reads: Skip QC, start with user-provided cleaned reads
4. From contigs: Skip QC and assembly (future feature)

Author: Lab Virome QC Team
License: MIT
"""

import os
import sys
from pathlib import Path

# Add scripts directory to Python path
workflow_dir = Path(workflow.basedir)
scripts_dir = workflow_dir / "scripts"
sys.path.insert(0, str(scripts_dir))

from sample_utils import get_samples

# ================================================================================
# Configuration and Validation
# ================================================================================

configfile: "config/config.yaml"

# Sample information
SAMPLES = get_samples(config)

# Output directory
OUTDIR = config["output_dir"]

# Reference paths
REFERENCES = config["references"]

# Pipeline control
PIPELINE_CONFIG = config.get("pipeline", {})
START_FROM = PIPELINE_CONFIG.get("start_from", "raw_reads")
RUN_ASSEMBLY = PIPELINE_CONFIG.get("run_assembly", False)
ASSEMBLY_STRATEGY = PIPELINE_CONFIG.get("assembly_strategy", "coassembly")

# ================================================================================
# Configuration Validation
# ================================================================================

def validate_config():
    """Validate pipeline configuration and provide helpful error messages"""

    # Check start_from value
    valid_start_points = ["raw_reads", "cleaned_reads", "contigs"]
    if START_FROM not in valid_start_points:
        raise ValueError(
            f"Invalid pipeline.start_from: '{START_FROM}'. "
            f"Must be one of: {valid_start_points}"
        )

    # If starting from cleaned reads, need cleaned_reads_dir
    if START_FROM == "cleaned_reads":
        if "cleaned_reads_dir" not in PIPELINE_CONFIG or not PIPELINE_CONFIG["cleaned_reads_dir"]:
            raise ValueError(
                "pipeline.start_from='cleaned_reads' but pipeline.cleaned_reads_dir not specified!\n"
                "Please add: pipeline:\n  cleaned_reads_dir: 'path/to/cleaned/reads'"
            )

        # Check if directory exists
        cleaned_dir = PIPELINE_CONFIG["cleaned_reads_dir"]
        if not os.path.exists(cleaned_dir):
            raise FileNotFoundError(
                f"pipeline.cleaned_reads_dir does not exist: {cleaned_dir}"
            )

    # Check assembly strategy
    valid_strategies = ["coassembly", "individual"]
    if ASSEMBLY_STRATEGY not in valid_strategies:
        raise ValueError(
            f"Invalid pipeline.assembly_strategy: '{ASSEMBLY_STRATEGY}'. "
            f"Must be one of: {valid_strategies}"
        )

    # Warn if assembly is requested but starting from contigs
    if START_FROM == "contigs" and RUN_ASSEMBLY:
        print("WARNING: pipeline.run_assembly=true but start_from='contigs'. Assembly will be skipped.")

    print(f"✓ Configuration valid")
    print(f"  Start from: {START_FROM}")
    print(f"  Run assembly: {RUN_ASSEMBLY}")
    if RUN_ASSEMBLY:
        print(f"  Assembly strategy: {ASSEMBLY_STRATEGY}")

# Run validation
validate_config()

# ================================================================================
# Module Imports
# ================================================================================

# Always include QC module rules (even if starting from cleaned reads,
# we need the rule definitions for dependency resolution)
include: "rules/qc.smk"

# Include assembly module if assembly is requested
if RUN_ASSEMBLY:
    include: "rules/assembly.smk"

# ================================================================================
# Target Rule - Conditional Outputs
# ================================================================================

def get_final_outputs():
    """
    Determine final outputs based on pipeline configuration

    Returns list of files that should be generated
    """
    outputs = []

    # ===== QC Outputs =====
    # Include QC outputs if starting from raw reads
    if START_FROM == "raw_reads":
        outputs.extend([
            # Final QC report
            f"{OUTDIR}/multiqc/multiqc_report.html",
            # ViromeQC results
            expand(f"{OUTDIR}/viromeqc/{{sample}}_viromeqc.txt", sample=SAMPLES),
            # Read count tracking
            f"{OUTDIR}/reports/read_counts.tsv",
            # Sample QC flags
            f"{OUTDIR}/reports/sample_qc_flags.tsv",
            # Contamination flagging
            f"{OUTDIR}/reports/contamination_summary.tsv",
            f"{OUTDIR}/reports/contamination_bars.png",
            f"{OUTDIR}/reports/contamination_boxes.png",
            f"{OUTDIR}/reports/contamination_scatter.png",
            f"{OUTDIR}/reports/contamination_heatmap.png",
            # Clean reads checkpoint
            expand(f"{OUTDIR}/clean_reads/{{sample}}_R1_clean.fastq.gz", sample=SAMPLES),
            expand(f"{OUTDIR}/clean_reads/{{sample}}_R2_clean.fastq.gz", sample=SAMPLES),
        ])

    # ===== Assembly Outputs =====
    # Include assembly outputs if assembly is requested and not starting from contigs
    if RUN_ASSEMBLY and START_FROM != "contigs":
        # BBMerge outputs (needed for assembly)
        outputs.extend(
            expand(f"{OUTDIR}/bbmerge/{{sample}}_merged.fastq.gz", sample=SAMPLES)
        )
        outputs.extend(
            expand(f"{OUTDIR}/bbmerge/{{sample}}_R1_unmerged.fastq.gz", sample=SAMPLES)
        )
        outputs.extend(
            expand(f"{OUTDIR}/bbmerge/{{sample}}_R2_unmerged.fastq.gz", sample=SAMPLES)
        )

        # Assembly outputs
        if ASSEMBLY_STRATEGY == "coassembly":
            outputs.extend([
                f"{OUTDIR}/assembly/megahit/final.contigs.fa",
                f"{OUTDIR}/reports/assembly_stats.tsv"
            ])
        elif ASSEMBLY_STRATEGY == "individual":
            outputs.extend(
                expand(f"{OUTDIR}/assembly/per_sample/{{sample}}/final.contigs.fa", sample=SAMPLES)
            )
            outputs.append(f"{OUTDIR}/reports/assembly_stats.tsv")

    return outputs


rule all:
    input:
        get_final_outputs()
    default_target: True


# ================================================================================
# Pipeline Summary
# ================================================================================

onstart:
    print("\n" + "="*80)
    print("Lab Virome QC Pipeline - Modular Version")
    print("="*80)
    print(f"Pipeline configuration:")
    print(f"  Start from: {START_FROM}")
    print(f"  Run assembly: {RUN_ASSEMBLY}")
    if RUN_ASSEMBLY:
        print(f"  Assembly strategy: {ASSEMBLY_STRATEGY}")
    print(f"  Samples: {len(SAMPLES)}")
    print(f"  Output directory: {OUTDIR}")
    print("="*80 + "\n")


onsuccess:
    print("\n" + "="*80)
    print("✓ Pipeline completed successfully!")
    print("="*80)
    print(f"Outputs available in: {OUTDIR}")
    if START_FROM == "raw_reads":
        print(f"  - QC reports: {OUTDIR}/reports/")
        print(f"  - Clean reads: {OUTDIR}/clean_reads/")
    if RUN_ASSEMBLY:
        if ASSEMBLY_STRATEGY == "coassembly":
            print(f"  - Assembly: {OUTDIR}/assembly/megahit/final.contigs.fa")
        else:
            print(f"  - Assemblies: {OUTDIR}/assembly/per_sample/*/final.contigs.fa")
    print("="*80 + "\n")


onerror:
    print("\n" + "="*80)
    print("✗ Pipeline failed!")
    print("="*80)
    print("Check log files in:")
    print(f"  {OUTDIR}/logs/")
    print("="*80 + "\n")
